#include "resourcemanager.h"
QMap<QString,QOpenGLShaderProgram*> ResourceManager::Shaders;
QMap<QString,QOpenGLTexture*> ResourceManager::Textures;
QOpenGLShaderProgram& ResourceManager::LoadShader(QString vShaderFile,QString fShaderFile,QString gShaderFile,QString name)
{
    Shaders[name]=new QOpenGLShaderProgram;
    Shaders[name]->addShaderFromSourceFile(QOpenGLShader::Vertex,vShaderFile);
    Shaders[name]->addShaderFromSourceFile(QOpenGLShader::Fragment,fShaderFile);
    if(!gShaderFile.isEmpty())
        Shaders[name]->addShaderFromSourceFile(QOpenGLShader::Geometry,gShaderFile);
    Shaders[name]->link();

    return *Shaders[name];
}
QOpenGLShaderProgram& ResourceManager::GetShader(QString name)
{
    return *Shaders[name];
}
QOpenGLTexture& ResourceManager::LoadTexture(QString file,bool alpha,QString name)
{
//    void QOpenGLTexture::setData(const QImage &image, QOpenGLTexture::MipMapGeneration genMipMaps = GenerateMipMaps)
//    This overload of setData() will allocate storage for you. The pixel data is contained in image. Mipmaps are generated by default. Set genMipMaps to DontGenerateMipMaps to turn off mipmap generation.
//    This is an overloaded function.
    Textures[name]=new QOpenGLTexture(QImage(file));
//    Textures.insert(name,QOpenGLTexture(QImage(file).mirrored()));
    Textures[name]->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
    Textures[name]->setMagnificationFilter(QOpenGLTexture::Linear);
    return *Textures[name];
}
QOpenGLTexture& ResourceManager::GetTexture(QString name)
{
    return *Textures[name];
}
void ResourceManager::Clear()
{
    for(auto iter:Shaders){
        delete iter;
    }
    Shaders.clear();
    for(auto iter:Textures){
        delete iter;
    }
    Textures.clear();
}
